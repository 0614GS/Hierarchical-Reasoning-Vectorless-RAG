{"node_id": "a8b5a4", "title": "Handle interrupts", "path": "human-in-the-loop > Human-in-the-loop > Handle interrupts", "content": "When an interrupt is triggered, the agent pauses execution and returns control. Check for interrupts in the result and handle them accordingly.\n\n```python  theme={null}\nimport uuid\nfrom langgraph.types import Command\n\n# Create config with thread_id for state persistence\nconfig = {\"configurable\": {\"thread_id\": str(uuid.uuid4())}}\n\n# Invoke the agent\nresult = agent.invoke({\n    \"messages\": [{\"role\": \"user\", \"content\": \"Delete the file temp.txt\"}]\n}, config=config)\n\n# Check if execution was interrupted\nif result.get(\"__interrupt__\"):\n    # Extract interrupt information\n    interrupts = result[\"__interrupt__\"][0].value\n    action_requests = interrupts[\"action_requests\"]\n    review_configs = interrupts[\"review_configs\"]\n\n    # Create a lookup map from tool name to review config\n    config_map = {cfg[\"action_name\"]: cfg for cfg in review_configs}\n\n    # Display the pending actions to the user\n    for action in action_requests:\n        review_config = config_map[action[\"name\"]]\n        print(f\"Tool: {action['name']}\")\n        print(f\"Arguments: {action['args']}\")\n        print(f\"Allowed decisions: {review_config['allowed_decisions']}\")\n\n    # Get user decisions (one per action_request, in order)\n    decisions = [\n        {\"type\": \"approve\"}  # User approved the deletion\n    ]\n\n    # Resume execution with decisions\n    result = agent.invoke(\n        Command(resume={\"decisions\": decisions}),\n        config=config  # Must use the same config!\n    )\n\n# Process final result\nprint(result[\"messages\"][-1].content)\n```", "summary": "Describes how to handle execution interrupts in an agent by checking for interrupt signals and resuming execution based on user decisions.", "keywords": ["interrupts", "agent", "execution", "user decisions", "resume", "config", "action_requests", "review_configs"]}